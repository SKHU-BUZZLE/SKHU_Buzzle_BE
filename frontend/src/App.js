
import React, { useState, useEffect, useRef } from 'react';
import { Client } from '@stomp/stompjs';
import SockJS from 'sockjs-client';
import './App.css';

const API_BASE_URL = 'http://localhost:8080';

function App() {
    const [jwt, setJwt] = useState('');
    const [stompClient, setStompClient] = useState(null);
    const [logs, setLogs] = useState([]);
    const [roomDetails, setRoomDetails] = useState(null);
    const [isHost, setIsHost] = useState(false);
    const [gameInfo, setGameInfo] = useState(null);
    const [currentQuestion, setCurrentQuestion] = useState(null);
    const [gameResult, setGameResult] = useState(null);

    // ÏûÖÎ†•Ïö© ÏÉÅÌÉú
    const [inviteCodeInput, setInviteCodeInput] = useState('');
    const [maxPlayers, setMaxPlayers] = useState(2);
    const [category, setCategory] = useState('ALL');
    const [quizCount, setQuizCount] = useState(3);

    const stompClientRef = useRef(null);
    stompClientRef.current = stompClient;

    const log = (message) => {
        console.log(message);
        const timestamp = new Date().toLocaleTimeString();
        const formattedMessage = typeof message === 'object' ? JSON.stringify(message, null, 2) : message;
        setLogs(prevLogs => [`[${timestamp}] ${formattedMessage}`, ...prevLogs]);
    };

    useEffect(() => {
        return () => {
            if (stompClientRef.current) {
                log('Disconnecting...');
                stompClientRef.current.deactivate();
            }
        };
    }, []);

    const handleCreateRoom = async () => {
        if (!jwt) {
            log('JWT ÌÜ†ÌÅ∞ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.');
            return;
        }
        log('Î∞© ÏÉùÏÑ± ÏöîÏ≤≠...');
        try {
            const response = await fetch(`${API_BASE_URL}/api/multi-room`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${jwt}`
                },
                body: JSON.stringify({ maxPlayers, category, quizCount })
            });

            const data = await response.json();
            if (response.ok) {
                log('Î∞© ÏÉùÏÑ± ÏÑ±Í≥µ:');
                log(data.data);
                setInviteCodeInput(data.data.inviteCode);
            } else {
                log(`Î∞© ÏÉùÏÑ± Ïã§Ìå®: ${data.message}`);
            }
        } catch (error) {
            log(`Î∞© ÏÉùÏÑ± ÏóêÎü¨: ${error.message}`);
        }
    };

    const handleJoinRoom = () => {
        if (!jwt) {
            log('JWT ÌÜ†ÌÅ∞ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.');
            return;
        }
        if (!inviteCodeInput) {
            log('Ï¥àÎåÄ ÏΩîÎìúÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.');
            return;
        }

        if (stompClient) {
            log('Ïù¥ÎØ∏ Ïó∞Í≤∞ÎêòÏñ¥ ÏûàÏäµÎãàÎã§. Ïó∞Í≤∞ÏùÑ Ìï¥Ï†úÌïòÍ≥† Îã§Ïãú ÏãúÎèÑÌï©ÎãàÎã§.');
            stompClient.deactivate();
        }

        log(`Ïó∞Í≤∞ ÏãúÎèÑ... (Token: ${jwt.substring(0, 10)}...)`);

        const client = new Client({
            webSocketFactory: () => new SockJS(`${API_BASE_URL}/chat?authorization=${jwt}`),
            onConnect: () => {
                log('‚úÖ WebSocket Ïó∞Í≤∞ ÏÑ±Í≥µ!');
                setStompClient(client);

                // Í∞úÏù∏ Î©îÏãúÏßÄ Íµ¨ÎèÖ (Ï¥àÍ∏∞ Î∞© Ï†ïÎ≥¥ ÌöçÎìù)
                client.subscribe('/user/queue/room', (message) => {
                    const body = JSON.parse(message.body);
                    log('üì• [Í∞úÏù∏ Î©îÏãúÏßÄ ÏàòÏã†]:');
                    log(body);
                    if (body.type === 'JOINED_ROOM') {
                        const initialRoomDetails = body.data;
                        // Ï¥àÍ∏∞ ÌîåÎ†àÏù¥Ïñ¥ Î™©Î°ù ÏÑ§Ï†ï
                        setRoomDetails(initialRoomDetails);
                        
                        // Î∞©Ïû• Ïó¨Î∂Ä ÌôïÏù∏
                        if (initialRoomDetails.players.length === 1 && initialRoomDetails.players[0].name === initialRoomDetails.hostName) {
                            setIsHost(true);
                            log('üëë ÎãπÏã†Ïù¥ Î∞©Ïû•ÏûÖÎãàÎã§.');
                        }
                    }
                });

                // Î∞© Ï†ÑÏ≤¥ Î©îÏãúÏßÄ Íµ¨ÎèÖ
                client.subscribe(`/topic/room/${inviteCodeInput}`, (message) => {
                    const body = JSON.parse(message.body);
                    log(`üì• [${inviteCodeInput} Î∞© Î©îÏãúÏßÄ ÏàòÏã†]:`);
                    log(body);

                    switch (body.type) {
                        case 'PLAYER_JOINED':
                            setRoomDetails(prev => {
                                if (!prev) return null;
                                // Ï§ëÎ≥µ ÏûÖÏû• Î∞©ÏßÄ
                                if (prev.players.some(p => p.email === body.email)) return prev;

                                const newPlayer = { 
                                    email: body.email, 
                                    name: body.name, 
                                    picture: body.picture, 
                                    isHost: prev.players.length === 0 // Ï≤´ ÌîåÎ†àÏù¥Ïñ¥Îäî Î∞©Ïû•
                                };

                                const newPlayers = [...prev.players, newPlayer];
                                return {
                                    ...prev,
                                    players: newPlayers,
                                    currentPlayerCount: newPlayers.length,
                                    canStartGame: newPlayers.length >= 2
                                };
                            });
                            break;
                        case 'PLAYER_LEFT':
                            setRoomDetails(prev => {
                                if (!prev) return null;
                                const newPlayers = prev.players.filter(p => p.email !== body.email);
                                return {
                                    ...prev,
                                    players: newPlayers,
                                    currentPlayerCount: newPlayers.length,
                                    canStartGame: newPlayers.length >= 2
                                };
                            });
                            break;
                        case 'MESSAGE':
                            alert(body.message); // Î∞© Ìè≠Ìåå Îì± Ï§ëÏöî Î©îÏãúÏßÄ
                            handleDisconnect();
                            break;
                        case 'GAME_START':
                            setGameInfo({ totalQuestions: body.totalQuestions });
                            setCurrentQuestion(null);
                            setGameResult(null);
                            break;
                        case 'QUESTION':
                            setCurrentQuestion(body);
                            break;
                        case 'ANSWER_RESULT':
                             // UIÏóê Ï†ïÎãµ Í≤∞Í≥º ÌëúÏãú Î°úÏßÅ (Ïòà: O/X ÌëúÏãú)
                            break;
                        case 'LEADERBOARD':
                            // UIÏóê Î¶¨ÎçîÎ≥¥Îìú ÏóÖÎç∞Ïù¥Ìä∏
                            break;
                        case 'GAME_END':
                            setGameResult(body);
                            setCurrentQuestion(null);
                            break;
                        default:
                            break;
                    }
                });

                log(`[${inviteCodeInput}] Î∞©Ïóê ÏûÖÏû•Ìï©ÎãàÎã§...`);
                client.publish({
                    destination: '/app/room/join',
                    body: JSON.stringify({ inviteCode: inviteCodeInput })
                });
            },
            onStompError: (frame) => {
                log('Broker reported error: ' + frame.headers['message']);
                log('Additional details: ' + frame.body);
            },
            onWebSocketError: (event) => {
                log('WebSocket error: ' + event);
            },
            reconnectDelay: 5000,
        });

        client.activate();
    };

    const handleStartGame = () => {
        if (stompClient && roomDetails) {
            log('Í≤åÏûÑ ÏãúÏûë ÏöîÏ≤≠!');
            stompClient.publish({
                destination: `/app/room/${roomDetails.roomId}/start`,
                body: ''
            });
        }
    };
    
    const handleAnswerSubmit = (answerIndex) => {
        if (stompClient && roomDetails && currentQuestion) {
            log(`${answerIndex + 1}Î≤à ÎãµÎ≥Ä Ï†úÏ∂ú`);
            stompClient.publish({
                destination: `/app/room/${roomDetails.roomId}/answer`,
                body: JSON.stringify({ 
                    questionIndex: currentQuestion.questionIndex,
                    index: answerIndex 
                })
            });
        }
    };

    const handleDisconnect = () => {
        if (stompClient) {
            stompClient.deactivate();
            setStompClient(null);
            setRoomDetails(null);
            setIsHost(false);
            setGameInfo(null);
            setCurrentQuestion(null);
            setGameResult(null);
            log('Ïó∞Í≤∞ Ìï¥Ï†ú');
        }
    };


    return (
        <div className="App">
            <div className="container">
                <h1>Buzzle Multi-Room Tester</h1>
                <div className="section">
                    <h2>1. Ïù∏Ï¶ù (JWT)</h2>
                    <input
                        type="text"
                        placeholder="JWT Token"
                        value={jwt}
                        onChange={(e) => setJwt(e.target.value)}
                        className="jwt-input"
                    />
                </div>

                <hr />

                <div className="section">
                    <h2>2. Î∞© ÏÉùÏÑ± (Î∞©Ïû•Ïö©)</h2>
                    <div>
                        <label>Max Players: </label>
                        <input type="number" value={maxPlayers} onChange={e => setMaxPlayers(parseInt(e.target.value))} min="2" max="10" />
                    </div>
                    <div>
                        <label>Category: </label>
                        <select value={category} onChange={e => setCategory(e.target.value)}>
                            <option value="ALL">ALL</option>
                            <option value="DATA_STRUCTURE">DATA_STRUCTURE</option>
                            <option value="OS">OS</option>
                            <option value="NETWORK">NETWORK</option>
                        </select>
                    </div>
                    <div>
                        <label>Quiz Count: </label>
                        <input type="number" value={quizCount} onChange={e => setQuizCount(parseInt(e.target.value))} min="3" max="20" />
                    </div>
                    <button onClick={handleCreateRoom}>Î∞© ÏÉùÏÑ±</button>
                </div>

                <hr />

                <div className="section">
                    <h2>3. Î∞© Ï∞∏Í∞Ä (Î™®Îëê)</h2>
                    <input
                        type="text"
                        placeholder="Ï¥àÎåÄ ÏΩîÎìú"
                        value={inviteCodeInput}
                        onChange={(e) => setInviteCodeInput(e.target.value)}
                    />
                    <button onClick={handleJoinRoom} disabled={!!stompClient}>Ï∞∏Í∞Ä</button>
                    <button onClick={handleDisconnect} disabled={!stompClient}>ÎÇòÍ∞ÄÍ∏∞</button>
                </div>
                
                <hr />

                {roomDetails && (
                    <div className="section">
                        <h2>4. Î∞© Ï†ïÎ≥¥</h2>
                        <p><strong>Ï¥àÎåÄ ÏΩîÎìú:</strong> {roomDetails.inviteCode}</p>
                        <p><strong>Î∞©Ïû•:</strong> {roomDetails.hostName}</p>
                        <p><strong>Ïù∏Ïõê:</strong> {roomDetails.currentPlayerCount} / {roomDetails.maxPlayers}</p>
                        <h3>ÌîåÎ†àÏù¥Ïñ¥ Î™©Î°ù</h3>
                        <ul>
                            {roomDetails.players.map((p, i) => <li key={i}>{p.name} {p.isHost ? 'üëë' : ''}</li>)}
                        </ul>
                        {isHost && <button onClick={handleStartGame} disabled={!roomDetails.canStartGame}>Í≤åÏûÑ ÏãúÏûë</button>}
                        {!roomDetails.canStartGame && isHost && <p><small>2Î™Ö Ïù¥ÏÉÅÏù¥Ïñ¥Ïïº ÏãúÏûëÌï† Ïàò ÏûàÏäµÎãàÎã§.</small></p>}
                    </div>
                )}

                {gameInfo && (
                     <div className="section">
                        <h2>5. Í≤åÏûÑ ÏßÑÌñâ</h2>
                        {currentQuestion ? (
                            <div>
                                <h3>Question {currentQuestion.questionIndex + 1}/{gameInfo.totalQuestions}</h3>
                                <p>{currentQuestion.question}</p>
                                <ul>
                                    {currentQuestion.options.map((opt, index) => (
                                        <li key={index}>
                                            <button onClick={() => handleAnswerSubmit(index)}>
                                                {index + 1}. {opt}
                                            </button>
                                        </li>
                                    ))}
                                </ul>
                            </div>
                        ) : (
                            <p>Îã§Ïùå Î¨∏Ï†úÎ•º Í∏∞Îã§Î¶¨Îäî Ï§ë...</p>
                        )}
                        {gameResult && (
                            <div>
                                <h3>Í≤åÏûÑ Ï¢ÖÎ£å!</h3>
                                <p>üèÜ ÏäπÏûê: {gameResult.winnerName}</p>
                            </div>
                        )}
                    </div>
                )}


            </div>
            <div className="logs-container">
                <h2>Logs</h2>
                <div className="logs">
                    {logs.map((logMsg, i) => <pre key={i}>{logMsg}</pre>)}
                </div>
            </div>
        </div>
    );
}

export default App;
