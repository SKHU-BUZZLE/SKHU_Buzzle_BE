package shop.buzzle.buzzle.multiroom.application;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.event.EventListener;
import org.springframework.messaging.simp.SimpMessageHeaderAccessor;
import org.springframework.messaging.simp.SimpMessageSendingOperations;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import shop.buzzle.buzzle.member.domain.Member;
import shop.buzzle.buzzle.member.domain.repository.MemberRepository;
import shop.buzzle.buzzle.member.exception.MemberNotFoundException;
import shop.buzzle.buzzle.multiroom.api.dto.request.MultiRoomJoinReqDto;
import shop.buzzle.buzzle.multiroom.api.dto.response.MultiRoomEventResponse;
import shop.buzzle.buzzle.multiroom.api.dto.response.GameEndResponseDto;
import shop.buzzle.buzzle.multiroom.domain.MultiRoom;
import shop.buzzle.buzzle.multiroom.event.MultiRoomGameStartEvent;
import shop.buzzle.buzzle.multiroom.exception.MultiRoomNotFoundException;
import shop.buzzle.buzzle.quiz.api.dto.request.QuizSizeReqDto;
import shop.buzzle.buzzle.quiz.api.dto.response.QuizResDto;
import shop.buzzle.buzzle.quiz.application.QuizService;
import shop.buzzle.buzzle.quiz.domain.QuizScore;
import shop.buzzle.buzzle.websocket.api.dto.AnswerRequest;
import shop.buzzle.buzzle.websocket.api.dto.Question;
import shop.buzzle.buzzle.game.api.dto.WebSocketAnswerResponse;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.*;

@Service
@RequiredArgsConstructor
@Slf4j
public class MultiRoomWebSocketService {

    private final MultiRoomService multiRoomService;
    private final QuizService quizService;
    private final MemberRepository memberRepository;
    private final SimpMessageSendingOperations messagingTemplate;

    private final Map<String, MultiRoomGameSession> gameSessions = new ConcurrentHashMap<>();
    private final Map<String, Object> roomLocks = new ConcurrentHashMap<>();
    private final Map<String, List<ScheduledFuture<?>>> roomTimers = new ConcurrentHashMap<>();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(10);

    public void joinRoom(String playerEmail, MultiRoomJoinReqDto request, SimpMessageHeaderAccessor headerAccessor) {
        try {
            // ÎÑê Í∞í Í≤ÄÏ¶ù
            if (playerEmail == null || playerEmail.trim().isEmpty()) {
                throw new IllegalArgumentException("ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Î©îÏùºÏù¥ ÎπÑÏñ¥ÏûàÏäµÎãàÎã§.");
            }

            if (request == null) {
                throw new IllegalArgumentException("ÏöîÏ≤≠ Îç∞Ïù¥ÌÑ∞Í∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§.");
            }

            log.info("üö™ [ROOM_JOIN_START] Player: {}, InviteCode: {}", playerEmail, request.inviteCode());

            var roomInfo = multiRoomService.joinRoom(playerEmail, request);

            if (roomInfo == null) {
                throw new RuntimeException("Î∞© Ï∞∏Í∞Ä ÏùëÎãµÏù¥ nullÏûÖÎãàÎã§.");
            }

            String roomId = roomInfo.roomId();
            String inviteCode = roomInfo.inviteCode();

            if (roomId == null || inviteCode == null) {
                log.error("‚ùå [ROOM_JOIN_ERROR] roomId or inviteCode is null. roomId: {}, inviteCode: {}", roomId, inviteCode);
                throw new RuntimeException("Î∞© ID ÎòêÎäî Ï¥àÎåÄÏΩîÎìúÍ∞Ä nullÏûÖÎãàÎã§.");
            }

            if (headerAccessor != null && headerAccessor.getSessionAttributes() != null) {
                headerAccessor.getSessionAttributes().put("roomId", roomId);
                headerAccessor.getSessionAttributes().put("inviteCode", inviteCode);
            } else {
                log.warn("‚ö†Ô∏è [ROOM_JOIN_WARNING] headerAccessor or sessionAttributes is null");
            }

            messagingTemplate.convertAndSendToUser(
                    playerEmail,
                    "/queue/room",
                    MultiRoomEventResponse.joinedRoom(roomInfo)
            );

            MultiRoom room = multiRoomService.getRoom(roomId);
            if (room == null) {
                log.error("‚ùå [ROOM_JOIN_ERROR] room is null after join. roomId: {}", roomId);
                throw new RuntimeException("Î∞© Ï∞∏Í∞Ä ÌõÑ Î∞©ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
            }

            Member player = memberRepository.findByEmail(playerEmail)
                    .orElseThrow(() -> new MemberNotFoundException("Ï∞∏Í∞ÄÏûêÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."));

            // Î∞© Ï†ÑÏ≤¥Ïóê ÏûÖÏû• ÏïåÎ¶º
            messagingTemplate.convertAndSend(
                    "/topic/room/" + inviteCode,
                    MultiRoomEventResponse.playerJoined(player)
            );

        } catch (Exception e) {
            log.error("‚ùå [ROOM_JOIN_ERROR] Player: {}, Error: {}", playerEmail, e.getMessage(), e);

            if (playerEmail != null && messagingTemplate != null) {
                try {
                    messagingTemplate.convertAndSendToUser(
                            playerEmail,
                            "/queue/room",
                            MultiRoomEventResponse.error("Î∞© Ï∞∏Í∞Ä Ïã§Ìå®: " + e.getMessage())
                    );
                } catch (Exception sendError) {
                    log.error("‚ùå [ERROR_SEND_FAILED] Failed to send error message to user: {}", sendError.getMessage());
                }
            }
        }
    }

    public void leaveRoom(String roomId, String playerEmail) {
        try {
            MultiRoom room = multiRoomService.getRoom(roomId);
            if (room == null) return;

            String inviteCode = room.getInviteCode();
            boolean isHost = room.isHost(playerEmail);

            multiRoomService.leaveRoom(roomId, playerEmail);

            // Î∞©Ïû•Ïù¥ ÎÇòÍ∞ÄÎ©¥ Î∞© Ìè≠Ìåå, ÏïÑÎãàÎ©¥ Ìá¥Ïû• ÏïåÎ¶º
            if (isHost) {
                messagingTemplate.convertAndSend(
                        "/topic/room/" + inviteCode,
                        MultiRoomEventResponse.message("Î∞©Ïû•Ïù¥ Ìá¥Ïû•ÌïòÏó¨ Î∞©Ïù¥ Ìï¥Ï≤¥ÎêòÏóàÏäµÎãàÎã§.")
                );
                gameSessions.remove(roomId);
                roomLocks.remove(roomId);
                cancelRoomTimers(roomId);
                log.info("‚ùå [ROOM_DISBANDED] Host left, InviteCode: {} disbanded", inviteCode);
            } else {
                Member player = memberRepository.findByEmail(playerEmail)
                        .orElse(null);
                String playerName = player != null ? player.getName() : playerEmail;

                messagingTemplate.convertAndSend(
                        "/topic/room/" + inviteCode,
                        MultiRoomEventResponse.playerLeft(playerName)
                );
                log.info("‚úÖ [PLAYER_LEFT] Player: {} ({}), InviteCode: {}", playerName, playerEmail, inviteCode);
            }
        } catch (Exception e) {
            log.error("‚ùå [LEAVE_ROOM_ERROR] Player: {}, Error: {}", playerEmail, e.getMessage());
        }
    }

    public void startGame(String roomId, String hostEmail) {
        try {
            MultiRoom room = multiRoomService.getRoom(roomId);
            if (room == null) {
                throw new MultiRoomNotFoundException();
            }

            String inviteCode = room.getInviteCode();

            log.info("‚úÖ [GAME_START_REQUEST] Host: {}, Room: {}, Players: {}/{}",
                    hostEmail, inviteCode, room.getCurrentPlayerCount(), room.getMaxPlayers());

            multiRoomService.startGame(roomId, hostEmail);

            messagingTemplate.convertAndSend(
                    "/topic/room/" + inviteCode,
                    MultiRoomEventResponse.message("Í≤åÏûÑÏù¥ ÏãúÏûëÎê©ÎãàÎã§!")
            );

        } catch (Exception e) {
            MultiRoom room = multiRoomService.getRoom(roomId);
            String inviteCode = room != null ? room.getInviteCode() : "unknown";

            log.error("‚ùå [GAME_START_ERROR] Room: {}, Error: {}", inviteCode, e.getMessage());

            messagingTemplate.convertAndSend(
                    "/topic/room/" + inviteCode,
                    MultiRoomEventResponse.error("Í≤åÏûÑ ÏãúÏûë Ïã§Ìå®: " + e.getMessage())
            );
        }
    }

    @Transactional
    public void startMultiRoomGame(String roomId) {
        MultiRoom room = multiRoomService.getRoom(roomId);
        if (room == null) throw new MultiRoomNotFoundException();

        String inviteCode = room.getInviteCode();

        log.info("‚úÖ [GAME_STARTING] Room: {}, Players: {}, Category: {}, Quiz Count: {}",
                inviteCode, room.getCurrentPlayerCount(), room.getCategory(), room.getQuizCount());

        List<QuizResDto> quizzes = quizService
                .askForAdvice(new QuizSizeReqDto(room.getCategory(), room.getQuizCount()))
                .quizResDtos();

        List<Question> questions = quizzes.stream()
                .map(q -> new Question(
                        q.question(),
                        List.of(q.option1(), q.option2(), q.option3(), q.option4()),
                        q.answer()
                ))
                .toList();

        MultiRoomGameSession session = new MultiRoomGameSession(
                roomId,
                questions,
                room.getPlayerEmails(),
                room.getCategory()
        );

        gameSessions.put(roomId, session);

        Map<String, Object> gameStartPayload = Map.of(
            "type", "GAME_START",
            "totalQuestions", session.getTotalQuestions(),
            "countdownSeconds", 3
        );
        messagingTemplate.convertAndSend("/topic/room/" + inviteCode, gameStartPayload);

        log.info("‚úÖ [GAME_COUNTDOWN] Room: {}, Starting in 3 seconds...", inviteCode);

        CompletableFuture.delayedExecutor(3, TimeUnit.SECONDS).execute(() -> {
            sendCurrentQuestion(roomId);
        });
    }

    public void sendCurrentQuestion(String roomId) {
        MultiRoom room = multiRoomService.getRoom(roomId);
        if (room == null) return;
        String inviteCode = room.getInviteCode();

        MultiRoomGameSession session = gameSessions.get(roomId);
        if (session == null || session.isFinished()) return;

        Question q = session.getCurrentQuestion();
        if (q == null) return;

        Map<String, Object> payload = Map.of(
            "type", "QUESTION",
            "question", q.text(),
            "options", q.options(),
            "questionIndex", session.getCurrentQuestionIndex()
        );

        messagingTemplate.convertAndSend("/topic/room/" + inviteCode, payload);

        // ÌÉÄÏù¥Î®∏Í∞Ä Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏù¥ ÏïÑÎãå Í≤ΩÏö∞ÏóêÎßå ÏãúÏûë
        if (session.tryStartTimer()) {
            startQuestionTimer(roomId, inviteCode, 10);
        }
    }

    private void startQuestionTimer(String roomId, String inviteCode, int seconds) {
        MultiRoomGameSession session = gameSessions.get(roomId);
        if (session == null) return;

        // Í∏∞Ï°¥ ÌÉÄÏù¥Î®∏Îì§ Ï∑®ÏÜå
        cancelRoomTimers(roomId);

        List<ScheduledFuture<?>> timerTasks = new ArrayList<>();

        // ÌÉÄÏù¥Î®∏ Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ Ïä§ÏºÄÏ§Ñ
        for (int i = seconds; i > 0; i--) {
            final int currentSecond = i;
            ScheduledFuture<?> timerTask = scheduler.schedule(() -> {
                // ÏÑ∏ÏÖòÏù¥ ÎÅùÎÇ¨Í±∞ÎÇò ÌÉÄÏù¥Î®∏Í∞Ä Ï§ëÎã®ÎêòÏóàÏúºÎ©¥ ÌÉÄÏù¥Î®∏ Ï§ëÎã®
                if (session.isFinished() || !session.isTimerRunning()) return;

                Map<String, Object> timerPayload = Map.of(
                    "type", "TIMER",
                    "remainingTime", currentSecond
                );
                messagingTemplate.convertAndSend("/topic/room/" + inviteCode, timerPayload);
            }, seconds - i, TimeUnit.SECONDS);

            timerTasks.add(timerTask);
        }

        // ÏãúÍ∞Ñ Ï¢ÖÎ£å Ïä§ÏºÄÏ§Ñ
        ScheduledFuture<?> timeUpTask = scheduler.schedule(() -> {
            // ÏÑ∏ÏÖòÏù¥ ÎÅùÎÇ¨Í±∞ÎÇò ÌÉÄÏù¥Î®∏Í∞Ä Ï§ëÎã®ÎêòÏóàÏúºÎ©¥ ÏãúÍ∞Ñ Ï¢ÖÎ£å Ï≤òÎ¶¨ÌïòÏßÄ ÏïäÏùå
            if (session.isFinished() || !session.isTimerRunning()) return;

            Map<String, Object> timeUpPayload = Map.of(
                "type", "TIME_UP",
                "message", "ÏãúÍ∞ÑÏù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§!"
            );
            messagingTemplate.convertAndSend("/topic/room/" + inviteCode, timeUpPayload);

            // ÏãúÍ∞Ñ Ï¥àÍ≥º Ï≤òÎ¶¨
            if (!session.isFinished()) {
                roomLocks.putIfAbsent(roomId, new Object());
                synchronized (roomLocks.get(roomId)) {
                    // ÎßàÏßÄÎßâ Î¨∏Ï†úÏù∏ Í≤ΩÏö∞ Î∞îÎ°ú Í≤åÏûÑ Ï¢ÖÎ£å
                    if (session.getCurrentQuestionIndex() >= session.getTotalQuestions() - 1) {
                        session.tryNextQuestion(); // Í≤åÏûÑÏùÑ finished ÏÉÅÌÉúÎ°ú ÎßåÎì§Í∏∞
                        handleMultiRoomGameEnd(roomId, session);
                        roomLocks.remove(roomId);
                    } else {
                        // ÎßàÏßÄÎßâ Î¨∏Ï†úÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞ Îã§Ïùå Î¨∏Ï†úÎ°ú
                        if (session.tryNextQuestion()) {
                            if (session.isFinished()) {
                                handleMultiRoomGameEnd(roomId, session);
                                roomLocks.remove(roomId);
                            } else {
                                Map<String, Object> loadingPayload = Map.of(
                                    "type", "LOADING",
                                    "message", "3Ï¥à ÌõÑ Îã§Ïùå Î¨∏Ï†úÍ∞Ä Ï†ÑÏÜ°Îê©ÎãàÎã§."
                                );
                                messagingTemplate.convertAndSend("/topic/room/" + inviteCode, loadingPayload);

                                scheduler.schedule(() -> {
                                    synchronized (roomLocks.get(roomId)) {
                                        sendCurrentQuestion(roomId);
                                    }
                                }, 3, TimeUnit.SECONDS);
                            }
                        }
                    }
                }
            }
        }, seconds, TimeUnit.SECONDS);

        timerTasks.add(timeUpTask);

        // Î∞©Î≥Ñ ÌÉÄÏù¥Î®∏ Ï†ÄÏû•
        roomTimers.put(roomId, timerTasks);
    }

    private void cancelRoomTimers(String roomId) {
        List<ScheduledFuture<?>> timers = roomTimers.remove(roomId);
        if (timers != null) {
            for (ScheduledFuture<?> timer : timers) {
                timer.cancel(false);
            }
            log.info("‚èπÔ∏è [TIMERS_CANCELLED] Room: {} - {} timers cancelled", roomId, timers.size());
        }
    }

    @Transactional
    public void receiveMultiRoomAnswer(String roomId, String email, AnswerRequest answerRequest) {
        MultiRoom room = multiRoomService.getRoom(roomId);
        if (room == null) return;

        String inviteCode = room.getInviteCode();
        MultiRoomGameSession session = gameSessions.get(roomId);
        if (session == null || session.isFinished()) return;

        if (answerRequest.questionIndex() != session.getCurrentQuestionIndex()) return;

        roomLocks.putIfAbsent(roomId, new Object());

        synchronized (roomLocks.get(roomId)) {
            Question current = session.getCurrentQuestion();
            if (current == null) return;

            boolean isCorrect = current.isCorrectIndex(answerRequest.index());

            Member member = memberRepository.findByEmail(email)
                    .orElseThrow(MemberNotFoundException::new);
            String displayName = member.getName();

            int correctIndex = Integer.parseInt(current.answerIndex()) - 1;

            log.info("üìù [ANSWER_RECEIVED] Player: {}, Room: {}, Question: {}, Answer: {}, Correct: {}",
                    displayName, inviteCode, answerRequest.questionIndex() + 1, answerRequest.index() + 1, isCorrect);

            // ANSWER_RESULT Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ°
            WebSocketAnswerResponse answerResponse = WebSocketAnswerResponse.of(
                email,
                displayName,
                isCorrect,
                String.valueOf(correctIndex),
                String.valueOf(answerRequest.index())
            );
            messagingTemplate.convertAndSend("/topic/room/" + inviteCode, answerResponse);

            if (!isCorrect) return;

            boolean accepted = session.tryAnswerCorrect(email, answerRequest.index());
            if (!accepted) {
                log.warn("‚ö†Ô∏è [DUPLICATE_ANSWER] Player: {} already answered correctly for this question", displayName);
                return;
            }

            // LEADERBOARD Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ°
            String currentLeaderEmail = session.getCurrentLeader();
            String currentLeaderName = currentLeaderEmail != null ?
                memberRepository.findByEmail(currentLeaderEmail)
                    .map(Member::getName)
                    .orElse(currentLeaderEmail) : null;

            Map<String, Integer> currentScores = session.getCurrentScores();

            // Ïù¥Î©îÏùº -> Ïù¥Î¶Ñ Îß§Ìïë ÏÉùÏÑ±
            Map<String, String> emailToName = new HashMap<>();
            for (String userEmail : currentScores.keySet()) {
                Member user = memberRepository.findByEmail(userEmail)
                        .orElseThrow(MemberNotFoundException::new);
                emailToName.put(userEmail, user.getName());
            }

            Map<String, Object> leaderboardPayload = Map.of(
                "type", "LEADERBOARD",
                "currentLeader", currentLeaderName,
                "currentLeaderEmail", currentLeaderEmail,
                "scores", currentScores,
                "emailToName", emailToName
            );
            messagingTemplate.convertAndSend("/topic/room/" + inviteCode, leaderboardPayload);

            if (session.tryNextQuestion()) {
                // Îã§Ïùå Î¨∏Ï†úÎ°ú ÎÑòÏñ¥Í∞à Îïå ÌòÑÏû¨ ÌÉÄÏù¥Î®∏ Ï¶âÏãú Ï§ëÎã®
                session.stopTimer();
                cancelRoomTimers(roomId);

                if (session.isFinished()) {
                    log.info("üèÅ [GAME_FINISHED] Room: {}, Moving to game end", inviteCode);
                    handleMultiRoomGameEnd(roomId, session);
                    roomLocks.remove(roomId);
                } else {
                    log.info("‚è≠Ô∏è [NEXT_QUESTION] Room: {}, Question {}/{} completed, preparing next question",
                            inviteCode, session.getCurrentQuestionIndex(), session.getTotalQuestions());

                    // ÌÉÄÏù¥Î®∏ Ï§ëÎã® ÏïåÎ¶º
                    Map<String, Object> timerStopPayload = Map.of(
                        "type", "TIMER_STOP",
                        "message", "Ï†ïÎãµ! Îã§Ïùå Î¨∏Ï†úÎ°ú Ïù¥ÎèôÌï©ÎãàÎã§."
                    );
                    messagingTemplate.convertAndSend("/topic/room/" + inviteCode, timerStopPayload);

                    Map<String, Object> loadingPayload = Map.of(
                        "type", "LOADING",
                        "message", "3Ï¥à ÌõÑ Îã§Ïùå Î¨∏Ï†úÍ∞Ä Ï†ÑÏÜ°Îê©ÎãàÎã§."
                    );
                    messagingTemplate.convertAndSend("/topic/room/" + inviteCode, loadingPayload);

                    scheduler.schedule(() -> {
                        synchronized (roomLocks.get(roomId)) {
                            sendCurrentQuestion(roomId);
                        }
                    }, 3, TimeUnit.SECONDS);
                }
            }
        }
    }

    private void handleMultiRoomGameEnd(String roomId, MultiRoomGameSession session) {
        MultiRoom room = multiRoomService.getRoom(roomId);
        if (room == null) return;

        String inviteCode = room.getInviteCode();

        // Îû≠ÌÇπ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
        Map<String, Integer> scores = session.getCurrentScores();
        List<String> allPlayerEmails = room.getPlayerEmails();
        GameEndResponseDto.GameEndData gameEndData = multiRoomService.createGameEndRanking(scores, allPlayerEmails);

        // Ïö∞ÏäπÏûêÏóêÍ≤å Ï†êÏàò Î∂ÄÏó¨
        String winner = session.getWinner();
        if (winner != null) {
            Member member = memberRepository.findByEmail(winner)
                    .orElseThrow(MemberNotFoundException::new);
            member.incrementStreak(QuizScore.MULTI_SCORE.getScore());
        }

        // Î°úÍ∑∏ Ï∂úÎ†•
        if (gameEndData.hasTie()) {
            log.info("ü§ù [GAME_TIE] Room: {}, Multiple winners with same score", inviteCode);
        } else if (winner != null) {
            Member member = memberRepository.findByEmail(winner)
                    .orElseThrow(MemberNotFoundException::new);
            log.info("üèÜ [GAME_WINNER] Room: {}, Winner: {}", inviteCode, member.getName());
        }

        // Îû≠ÌÇπ Ï†ïÎ≥¥ÏôÄ Ìï®Íªò Í≤åÏûÑ Ï¢ÖÎ£å Î©îÏãúÏßÄ Ï†ÑÏÜ°
        MultiRoomEventResponse gameEndResponse = MultiRoomEventResponse.gameEndWithRanking(gameEndData);
        messagingTemplate.convertAndSend("/topic/room/" + inviteCode, gameEndResponse);

        // Í≤åÏûÑ ÏÑ∏ÏÖò Ï†ïÎ¶¨
        gameSessions.remove(roomId);

        // ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
        cancelRoomTimers(roomId);

        // Î∞© Ìè≠Ìåå
        multiRoomService.disbandRoomAfterGame(roomId);

        log.info("üí• [ROOM_DISBANDED] Room: {} disbanded after game completion", inviteCode);
    }

    public void resendCurrentQuestionToUser(String roomId) {
        MultiRoom room = multiRoomService.getRoom(roomId);
        if (room == null) return;

        String inviteCode = room.getInviteCode();
        MultiRoomGameSession session = gameSessions.get(roomId);
        if (session == null || session.isFinished()) return;

        Question q = session.getCurrentQuestion();
        if (q == null) return;

        messagingTemplate.convertAndSend(
                "/topic/room/" + inviteCode,
                MultiRoomEventResponse.question(
                        q.text(),
                        q.options(),
                        session.getCurrentQuestionIndex()
                )
        );
    }

    @EventListener
    public void handleMultiRoomGameStart(MultiRoomGameStartEvent event) {
        startMultiRoomGame(event.roomId());
    }
}
